/*@!Encoding:1252*/
includes
{

}

variables
{
  
}


export testcase ctc_ControlInputMissing(int failCount1, int successCount1) {
  const int initialFanSpeed = 3000;
  const int speedMessagePeriod = 100;
  const long expectedInitialFanPWM = 28086;
  const long expectedErrorFanPWM = 3342;
  
  dword fanFaultSignalCheck;
  dword fanPwmSignalCheck;
  
  testStep("0.0", "Check Preconditions & Setup Check Conditions");
  fanFaultSignalCheck = ChkStart_SignalValueChange(Comfort::Signal_Fan_Fault);
  cf_expectValueNe(0, fanFaultSignalCheck, "Create Fan Fault Signal Value Change check");
  testAddCondition(fanFaultSignalCheck);
  cf_assertValueEq(0, $Comfort::Signal_Fan_Fault, "Initial Fault Signal");
  
  testStep("0.1", "Ensure reaction to Bus Messages");
  
  // Turn off Fan
  setSignal(Comfort::Signal_Fan_Speed, 0);
  cf_assertExitNotForTimeout(testWaitForSignalMatch(sysvarMember::VTT::Fan_ECU::Pwm::PWM_FanMotor.dutyCycle, 0, speedMessagePeriod + syspar::sourceCodeIterationTime));
  cf_assertValueEq(0, @sysvar::VTT::Fan_ECU::Pwm::PWM_FanMotor.dutyCycle, "Initial Fan PWM Part 1/2");
  
  // Initial Fan configuration
  setSignal(Comfort::Signal_Fan_Speed, initialFanSpeed);  
  // Verify that Fan is runnning
  cf_assertExitNotForTimeout(testWaitForSignalMatch(sysvarMember::VTT::Fan_ECU::Pwm::PWM_FanMotor.dutyCycle, expectedInitialFanPWM, speedMessagePeriod + syspar::sourceCodeIterationTime));
  
  fanPwmSignalCheck = ChkStart_SignalValueChange(sysvar::VTT::Fan_ECU::Pwm::PWM_FanMotor);
  cf_expectValueNe(0, fanPwmSignalCheck, "Create Fan PWM Signal Value Change check");
  testAddCondition(fanPwmSignalCheck);
  
  cf_assertValueEq(expectedInitialFanPWM, @sysvar::VTT::Fan_ECU::Pwm::PWM_FanMotor.dutyCycle,  "Initial Fan PWM Part 2/2");
  
  // fail count 1
  if (failCount1 > 0) { 
    testStep("1.0", "Disable Input Bus Message and check for detection");
    TestDisableMsg(HeadUnit_ECU::Comfort_HeadUnit_Frame_PDU);
    testWaitForTimeout(failCount1*speedMessagePeriod);
  }
  
  // success count 1
  if (successCount1 > 0) {
    testStep("1.1", "Reenable Input Bus Message");
    TestEnableMsg(HeadUnit_ECU::Comfort_HeadUnit_Frame_PDU);
    testWaitForTimeout(successCount1*speedMessagePeriod);
  }
  
  // Fail 3 times
  testStep("1.2", "No change for two message periods");
  TestDisableMsg(HeadUnit_ECU::Comfort_HeadUnit_Frame_PDU);
  testWaitForTimeout(2*speedMessagePeriod);
  cf_expectValueEq(0, TestRemoveCondition(fanPwmSignalCheck), "Could not remove PWM Signal check");
  cf_expectValueEq(0, TestRemoveCondition(fanFaultSignalCheck), "Could not remove Fan Fault Signal check");
  
  testStep("1.3", "Error after the third message cycle");
  
  // Wait for Fan to enter emergency operation speed
  ChkControl_Stop(fanFaultSignalCheck);
  ChkControl_Stop(fanPwmSignalCheck);
  cf_assertExitNotForTimeout(testWaitForSignalMatch(sysvarMember::VTT::Fan_ECU::Pwm::PWM_FanMotor.dutyCycle, expectedErrorFanPWM, syspar::sourceCodeIterationTime - 3*speedMessagePeriod));
  cf_assertValueEq(expectedErrorFanPWM, @sysvar::VTT::Fan_ECU::Pwm::PWM_FanMotor.dutyCycle, "Emergency Operation Fan PWM");
  cf_assertExitNotForTimeout(TestWaitForSignalMatch(Comfort::Signal_Fan_Fault, 1, syspar::sourceCodeIterationTime - 3*speedMessagePeriod));
  cf_assertValueEq(1, $Comfort::Signal_Fan_Fault, "Final Fault Signal");
}


export testcase ctc_ControlInputRestored() {
  const int requestedFanSpeed = 3000;
  const long expectedFanPWM = 28086;
  const long expectedErrorFanPWM = 3342; // Emergency PWM
  
  // Sequence with ControlInputMissing
  // Now, reenable the missing message and expect the fault to go away immediately
  cf_assertValueEq(1, $Comfort::Signal_Fan_Fault, "Final Fault Signal");
  cf_assertValueEq(expectedErrorFanPWM, @sysvar::VTT::Fan_ECU::Pwm::PWM_FanMotor.dutyCycle,  "Emergency Operation Fan PWM");
  cf_expectValueNe(expectedFanPWM, @sysvar::VTT::Fan_ECU::Pwm::PWM_FanMotor.dutyCycle,  "Requested PWM not different from emergency PWM");
  
  TestEnableMsg(HeadUnit_ECU::Comfort_HeadUnit_Frame_PDU);
  // Functionality restores instantly when messages come back.
  setSignal(Comfort::Signal_Fan_Speed, requestedFanSpeed);
  
  cf_assertExitNotForTimeout(testWaitForSignalMatch(sysvarMember::VTT::Fan_ECU::Pwm::PWM_FanMotor.dutyCycle, expectedFanPWM, syspar::sourceCodeIterationTime));
  cf_assertValueEq(expectedFanPWM, @sysvar::VTT::Fan_ECU::Pwm::PWM_FanMotor.dutyCycle,  "Restored Fan PWM");
  cf_assertExitNotForTimeout(TestWaitForSignalMatch(Comfort::Signal_Fan_Fault, 0, syspar::sourceCodeIterationTime));
  cf_assertValueEq(0, $Comfort::Signal_Fan_Fault, "Fault Signal Off");
}


export testcase ctc_FaultClearedByDrivingCycle() {
  const int requestedSpeed1 = 1900;
  const int requestedSpeed2 = 3000;
  const long expectedDutyCycle1 = 17788;
  const long expectedDutyCycle2 = 28086;
  const int speedMessagePeriod = 100;
  const int fanMessagePeriod = 100;
  
  int faultSignalCheck;
  int pwmCheck;
  
  testStep("0.0", "Ensure fault-free operation");
  setSignal(Comfort::Signal_Fan_Speed, requestedSpeed1);
  cf_assertExitNotForTimeout(testWaitForSignalMatch(sysvarMember::VTT::Fan_ECU::Pwm::PWM_FanMotor.dutyCycle, expectedDutyCycle1, speedMessagePeriod + syspar::sourceCodeIterationTime));
  cf_assertValueEq(expectedDutyCycle1, @sysvarMember::VTT::Fan_ECU::Pwm::PWM_FanMotor.dutyCycle, "Check PWM in fault case");  
  cf_assertValueEq(0, $Signal_Fan_Fault, "Check Fault Signal");  

  testStep("1.0", "Cause a fault in the motor");
  @sysvar::TestInterface::OpenLoop = 1;
  
  // Ensure that fault is reported on the bus
  // Ensure that PWM is no longer actuated
  cf_assertExitNotForTimeout(testWaitForSignalMatch(Comfort::Signal_Fan_Fault, 1, fanMessagePeriod + syspar::sourceCodeIterationTime));
  cf_assertValueEq(1, $Signal_Fan_Fault, "Check Fault Signal");  
  cf_assertExitNotForTimeout(testWaitForSignalMatch(sysvarMember::VTT::Fan_ECU::Pwm::PWM_FanMotor.dutyCycle, 0, speedMessagePeriod + syspar::sourceCodeIterationTime));
  cf_assertValueEq(0, @sysvarMember::VTT::Fan_ECU::Pwm::PWM_FanMotor.dutyCycle, "Check PWM in fault case");  
  
  testStep("1.1", "Remove Fault and add Checks to ensure that PWM is no longer actuated, even if the error goes away");
  
  // Observe Fault Signal and add Check as Condition
  faultSignalCheck = ChkStart_SignalValueChange(Comfort::Signal_Fan_Fault);
  cf_expectValueNe(0, faultSignalCheck, "Create Fan Fault Signal Value Change check");
  TestAddCondition(faultSignalCheck);
  
  // Observe PWM SysVar and add Check as Condition
  pwmCheck = ChkStart_SignalValueChange(sysvar::VTT::Fan_ECU::Pwm::PWM_FanMotor);
  cf_expectValueNe(0, pwmCheck, "Create Fan PWM Signal Value Change check");
  TestAddCondition(pwmCheck);
  
  // Remove Fault
  @sysvar::TestInterface::OpenLoop = 0;
  testWaitForTimeout(syspar::sourceCodeIterationTime);
  
  // Change the PWM, ensure that PWM still is not actuated
  setSignal(Comfort::Signal_Fan_Speed, requestedSpeed2);
  testWaitForTimeout(speedMessagePeriod + syspar::sourceCodeIterationTime);
  
  testStep("2.0", "Start new driving cycle");
  
  // Remove Checks as Conditions and Stop the Checks
  TestRemoveCondition(faultSignalCheck);
  TestRemoveCondition(pwmCheck);
  ChkControl_Stop(faultSignalCheck);
  ChkControl_Stop(pwmCheck);
  
  cf_RestartDrivingCycle();
  
  testStep("2.1", "Expect PWM to be actuated");
  
  cf_assertValueEq(requestedSpeed2, $Signal_Fan_Speed, "Check that Speed is still being requested");

  // Ensure that no fault is reported
  // Ensure that PWM is actuated
  cf_assertExitNotForTimeout(testWaitForSignalMatch(sysvarMember::VTT::Fan_ECU::Pwm::PWM_FanMotor.dutyCycle, expectedDutyCycle2, speedMessagePeriod + syspar::sourceCodeIterationTime));
  cf_assertValueEq(expectedDutyCycle2, @sysvarMember::VTT::Fan_ECU::Pwm::PWM_FanMotor.dutyCycle, "Check PWM");
  cf_assertValueEq(0, $Signal_Fan_Fault, "Check Fault Signal");
}