/*@!Encoding:1252*/
includes
{
  
}

variables
{
  const int electricalFaultConfirmationTime = 5000;
  const int electricalFaultAgingTime = 11000;
}


export void cf_ConfirmationElectricalDtc(double dtcNumber, int setOpenLoop, int setShortCircuit) {
  testStep("1.0", "Trigger Fault Event");
  setSignal(Comfort::Signal_Fan_Speed, 875);
  testWaitForTimeout(syspar::sourceCodeIterationTime);
  
  @sysvar::TestInterface::OpenLoop = setOpenLoop;
  @sysvar::TestInterface::ShortCircuit = setShortCircuit;
  
  cf_assertExitNotForTimeout(TestWaitForSignalMatch(Comfort::Signal_Fan_Fault, 1, syspar::sourceCodeIterationTime));
  cf_assertValueEq(1, $Signal_Fan_Fault, "Check that fault signal is set.");
  
  testStep("1.1", "After 1s DTC should not be confirmed yet");
  cf_assertDtcEvent(dtcNumber, 0, 0);
  
  testStep("1.2", "Check for DTC confirmation");
  testWaitForTimeout(electricalFaultConfirmationTime + syspar::sourceCodeIterationTime); // + sourceCodeIterationTime because sometimes not yet confirmed
  cf_assertDtcEvent(dtcNumber, 1, 1);
  
  testStep("1.3", "Check for active Fault Signal");
  cf_assertValueEq(1, $Signal_Fan_Fault, "Check that fault signal is still set");
}


export void cf_AgingElectricalDtc(double dtcNumber) {
  testStep("1.0", "Check Confirmed DTC and active Fault");
  cf_assertDtcEvent(dtcNumber, 1, 1);
  cf_assertValueEq(1, $Signal_Fan_Fault, "Check that fault signal is set");
  
  testStep("1.1", "Stop Driving Cycle and Remove Fault");
  setSignal(Comfort::Signal_DrivingCycle, 0);
  cf_InitState();
  
  testStep("1.2", "Restart Driving Cycle and Check Aging of DTC"); // Aging => DTC is removed from Fault Memory
  setSignal(Comfort::Signal_DrivingCycle, 1);
  cf_assertExitNotForTimeout(TestWaitForSignalMatch(Comfort::Signal_Fan_Fault, 0, syspar::sourceCodeIterationTime));
  cf_assertValueEq(0, $Signal_Fan_Fault, "Check if fault signal is not set.");
  
  // DTC should still be confirmed
  testWaitForTimeout(electricalFaultAgingTime-4000);
  cf_assertDtcEvent(dtcNumber, 1, 1);
  
  // DTC should be cleared
  testWaitForTimeout(4000 + syspar::sourceCodeIterationTime); // + sourceCodeIterationTime because sometimes not yet cleared
  cf_assertDtcEvent(dtcNumber, 0, 0);
}


void cf_StopRestartDrivingCycle() {
    setSignal(Comfort::Signal_DrivingCycle, 0);
    testWaitForTimeout(syspar::sourceCodeIterationTime);
    setSignal(Comfort::Signal_DrivingCycle, 1);
    testWaitForTimeout(syspar::sourceCodeIterationTime);
}


export void cf_ConfirmationMechanicalDtc(double dtcNumber, int setHighCurrent, int setLowCurrent) {
  int i;
  
  testStep("1.0", "Trigger Fault Event");
  setSignal(Comfort::Signal_Fan_Speed, 2625);
  testWaitForTimeout(syspar::sourceCodeIterationTime);
  
  @sysvar::TestInterface::HighCurrent = setHighCurrent;
  @sysvar::TestInterface::LowCurrent = setLowCurrent;
  
  cf_assertExitNotForTimeout(TestWaitForSignalMatch(Comfort::Signal_Fan_Fault, 1, syspar::sourceCodeIterationTime));
  cf_assertValueEq(1, $Signal_Fan_Fault, "Check that fault signal is set.");
  
  testStep("1.1", "Check for pending DTC");
  cf_assertDtcEvent(dtcNumber, 1, 0);
  
  testStep("1.2", "Wait for DTC confirmation");
  for (i = 0; i <= 2; i++) {
    // check that fault signal is set 
    cf_assertValueEq(1, $Signal_Fan_Fault, "Check that fault signal is set.");
    // check that DTC is still only pending
    cf_assertDtcEvent(dtcNumber, 1, 0);
    cf_StopRestartDrivingCycle();
  }
  
  testStep("1.3", "Check for DTC confirmation");
  cf_assertDtcEvent(dtcNumber, 1, 1);
  
  testStep("1.4", "Check for active Fault Signal");
  cf_assertExitNotForTimeout(TestWaitForSignalMatch(Comfort::Signal_Fan_Fault, 1, syspar::sourceCodeIterationTime));
  cf_assertValueEq(1, $Signal_Fan_Fault, "Check that fault signal is still set");
}


export void cf_AppearingDisappearingMechanicalDtc(double dtcNumber, int setHighCurrent, int setLowCurrent){
  int i;
  
  testStep("1.0", "Trigger Fault Event");
  setSignal(Comfort::Signal_Fan_Speed, 2625);
  testWaitForTimeout(syspar::sourceCodeIterationTime);
  
  @sysvar::TestInterface::HighCurrent = setHighCurrent;
  @sysvar::TestInterface::LowCurrent = setLowCurrent;
  
  cf_assertExitNotForTimeout(TestWaitForSignalMatch(Comfort::Signal_Fan_Fault, 1, syspar::sourceCodeIterationTime));
  cf_assertValueEq(1, $Signal_Fan_Fault, "Check if fault signal is set.");
  
  testStep("1.1", "Check for pending DTC");
  cf_assertDtcEvent(dtcNumber, 1, 0);
  
  testStep("2.0", "Start new Driving Cycle - Fault Trigger still activated");
  cf_StopRestartDrivingCycle();
  cf_assertValueEq(1, $Signal_Fan_Fault, "Check that fault signal is still set");
  
  testStep("2.1", "Check for pending DTC");
  cf_assertDtcEvent(dtcNumber, 1, 0);
  
  testStep("3.0", "Remove Fault and Start new Driving Cycle");
  @sysvar::TestInterface::HighCurrent = 0;
  @sysvar::TestInterface::LowCurrent = 0;
  cf_StopRestartDrivingCycle();
  cf_assertExitNotForTimeout(TestWaitForSignalMatch(Comfort::Signal_Fan_Fault, 0, syspar::sourceCodeIterationTime));
  cf_assertValueEq(0, $Signal_Fan_Fault, "Check that fault signal is not set");
  
  testStep("3.1", "Check for pending DTC");
  cf_assertDtcEvent(dtcNumber, 1, 0);
  
  testStep("4.0", "Start new Driving Cycle without Fault and check for passed DTC");
  cf_StopRestartDrivingCycle();
  cf_assertValueEq(0, $Signal_Fan_Fault, "Check that fault signal is not set");
  cf_assertDtcEvent(dtcNumber, 0, 0);
}


export void cf_NoAgingMechanicalDtc(double dtcNumber) {
  int i;
  
  testStep("1.0", "Check Confirmed DTC");
  cf_assertDtcEvent(dtcNumber, 1, 1);
  
  testStep("1.1", "Check for active Fault Signal");
  cf_assertValueEq(1, $Signal_Fan_Fault, "Check that fault signal is set");
  
  testStep("2.0", "Remove Fault and Start new Driving Cycle");
  cf_InitState();
  cf_StopRestartDrivingCycle();
  
  testStep("2.2", "Check for confirmed DTC"); 
  cf_assertExitNotForTimeout(TestWaitForSignalMatch(Comfort::Signal_Fan_Fault, 1, syspar::sourceCodeIterationTime));
  cf_assertValueEq(1, $Signal_Fan_Fault, "Check that fault signal is set.");
  
  // DTC should still be confirmed
  cf_assertDtcEvent(dtcNumber, 1, 1);
  
  testStep("3.0", "Start several new Driving Cycles and check for confirmed DTC");
  for (i = 0; i <= 4; i++) {
    cf_StopRestartDrivingCycle();
    // check that DTC is still confirmed
    cf_assertDtcEvent(dtcNumber, 1, 1);
  }
}