/*@!Encoding:1252*/
includes
{
  
}

variables
{
  const int diagTimeout = 10000;
  
  const cAccessModeNumerical=0;
  const cAccessModePhysical=1;
  const cAccessModeCoded=2;
}


void cf_StartDrivingCycleWithActuation() {
  setSignal(Comfort::Signal_DrivingCycle, 1);
  $HeadUnit_ECU::Signal_Fan_Speed = 850;
  cf_assertExitNotForTimeout(TestWaitForSignalMatch(Comfort::Signal_Fan_Fault, 1, syspar::sourceCodeIterationTime));
  cf_assertValueEq(1, $Signal_Fan_Fault, "Check that Fault is set");
  testWaitForTimeout(syspar::sourceCodeIterationTime);
  cf_assertValueEq(0, @sysvarMember::VTT::Fan_ECU::Pwm::PWM_FanMotor.value, "Check that motor is not actuated");
}
  


export testcase ctc_MechanicalFaultFunctionInhibition() {
  int setSpeed = 850;
  //const int expectedPwmActuated = 25;
  const int expectedPwmInhibited = 0;
  
  int i;
  int pwmCheck;
  int faultSignalCheck;
  
  
  testStep("1.0", "Prepare Fault Memory");
  // First cause a fault & confirmed DTC
  @sysvar::TestInterface::HighCurrent = 1;
  testWaitForTimeout(syspar::sourceCodeIterationTime);
  
  // i <= 3: because DTC event becomes confirmed if it fails again in the next operation cycle (3+1)
  for (i = 0; i <= 3; i++) {
    cf_StartDrivingCycleWithActuation();
    setSignal(Comfort::Signal_DrivingCycle, 0);
    testWaitForTimeout(syspar::sourceCodeIterationTime);
  }
  
  // Check for confirmed DTC from CAPL
  cf_assertDtcEvent(0x000019, 1, 1);
  
  testStep("1.5", "Clean restart of the ECU");
  // Remove fault, stop actuation
  @sysvar::TestInterface::HighCurrent = 0;
  $HeadUnit_ECU::Signal_Fan_Speed = 0;
  
  // Driving-Cycle the ECU. Motor should no longer be actuated.
  setSignal(Comfort::Signal_DrivingCycle, 1);
  testWaitForTimeout(syspar::sourceCodeIterationTime);
  
  pwmCheck = ChkStart_SignalValueChange(sysvar::VTT::Fan_ECU::Pwm::PWM_FanMotor);
  cf_expectValueNe(0, pwmCheck, "Create Fan PWM Signal Value Change check");
  cf_assertValueEq(0, @sysvarMember::VTT::Fan_ECU::Pwm::PWM_FanMotor.value, "Check that motor is not actuated");
  TestAddCondition(pwmCheck);
  
  faultSignalCheck = ChkStart_SignalValueChange(Comfort::Comfort_Fan_Frame_PDU::Signal_Fan_Fault);
  cf_expectValueNe(0, faultSignalCheck, "Create Fan Fault Signal Value Change check");
  cf_assertValueEq(0, $Signal_Fan_Fault, "Check that fault signal is not set");
  TestAddCondition(faultSignalCheck);
  
  testStep("2.0", "Test Function Inhibition");
  // Verify that DTC is still confirmed
  cf_assertDtcEvent(0x000019, 1, 1);
  // Verify that fault signal is off
  cf_assertValueEq(0, $Signal_Fan_Fault, "Check that fault signal is not set");
  
  // Remove Checks as Conditions and Stop the Checks
  TestRemoveCondition(faultSignalCheck);
  ChkControl_Stop(faultSignalCheck);
  
  // Request actuation. Check that no actuation occurs and that fault signal comes on.
  $Signal_Fan_Speed = setSpeed;
  testWaitForTimeout(syspar::sourceCodeIterationTime);
  cf_assertValueEq(0, @sysvarMember::VTT::Fan_ECU::Pwm::PWM_FanMotor.value, "Check that motor is not actuated");
  cf_assertExitNotForTimeout(TestWaitForSignalMatch(Comfort::Signal_Fan_Fault, 1, syspar::sourceCodeIterationTime));
  cf_assertValueEq(1, $Signal_Fan_Fault, "Check that fault signal is set");
  
  // Remove PWM Check as Condition and Stop the Check
  TestRemoveCondition(pwmCheck);
  ChkControl_Stop(pwmCheck);
}